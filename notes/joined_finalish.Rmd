---
title: "working_to_final"
output: word_document
date: "2025-10-30"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(out.width = "60%",fig.align='center')
```

1. Ethan + Sydney's data cleaning and transformation combined here.
## Load Libraries 
```{r}
# install.packages("here")   # only once allows us to all call from same space 
# install.packages("ResourceSelection")
# install.packages("randtests")
```
```{r}
library(tidyverse)
library(knitr)
library(tinytex) 
library(dplyr)
library(ggplot2)
library(readr)
library(tibble)
library(here)
library(ResourceSelection)
library(randtests)
library(purrr)
library(stringr)
library(mgcv)      # for GAM
library(glmmTMB)   # for mixed-effects logistic regression
```

## Load Datasets
```{r}
volley_points <- readr::read_csv(here("datasets", "volleyball_points_dataset.csv"))  
all_matches_CU <- readr::read_csv(here("datasets", "all_matches_CU.csv"))                #551 by 16
all_matches_opp <- readr::read_csv(here("datasets","all_matches_opp.csv"))               #551 by 16
all_matches_processed <- readr::read_csv(here("datasets","all_matches_processed.csv"))  #1102 by 16
all_matches <- readr::read_csv(here("datasets","all_matches (1).csv"))                 #269628 by 125 
```

##DATA CLEANING 
```{r}
#data inflow + outflow
in_path <- here::here("datasets", "all_matches (1).csv")
out_path <- "volleyball_points_dataset.csv"
```

```{r}
touches <- readr::read_csv(in_path, show_col_types = FALSE)

#normalize season column
touches <- touches %>%
  mutate(season = str_extract(season, "\\d{2}$"))

order_col <- if ("Unnamed: 0" %in% names(touches)) "Unnamed: 0" else NULL

#touches in correspondence to rally order   
touches_ord <- touches %>%
  {
    if (!is.null(order_col)) arrange(., match_id, set_number, .data[[order_col]])
    else group_by(., match_id, set_number) %>% arrange(row_number(), .by_group = TRUE) %>% ungroup()
  }
```
To compress rallies accurately, touches must be sorted in the exact sequence they occurred. We sort by match_id, set_number, and a stable row index so subsequent steps (like detecting score changes) behave correctly.

```{r}
#add flags for rally IDS + rally-ending scores 
touches_flagged <- touches_ord %>%
  filter(!is.na(home_team_score) | !is.na(visiting_team_score))  %>% # remove empty rows early 
  group_by(match_id, set_number) %>%
  mutate(
    prev_home  = lag(home_team_score),
    prev_away  = lag(visiting_team_score),
    rally_end_flag = (home_team_score != prev_home) | (visiting_team_score != prev_away),
    rally_end_flag = replace_na(rally_end_flag, TRUE),
    rally_id = cumsum(rally_end_flag),
    match_end_flag = last(to_logical_vec(won_match))  # NEW: indicates if this match was won by the "home" team 
    #TO LOOK AT WHOLE MATCH WIN PROB NOT JUST RALLY/SETS
  ) %>%
  ungroup()
```
Volleyball is rally scoring; each rally ends when the scoreboard moves. By turning score changes into a “flag” and cumulatively summing, every touch is assigned to the rally that produced (or followed) a point.

```{r}
#function to create binaries (T/F)
to_logical_vec <- function(x) {
  if (is.logical(x)) x
  else if (is.numeric(x)) x != 0
  else tolower(as.character(x)) %in% c("true","t","yes","y","1")
}
```
“Between points” events like timeouts are often recorded right after a point and before the next serve. We’ll roll them up with the rally that just ended (i.e., the point that triggered them).

```{r}
#collapse touches into rally-level dataset
points_core <- touches_flagged %>%
  group_by(match_id, set_number, rally_id) %>%
  summarise(
    home_score_end           = last(home_team_score),
    away_score_end           = last(visiting_team_score),
    serving_team             = first(serving_team),          
    touches_in_rally         = n(),
    team_rotation            = suppressWarnings(as.integer(last(team_rotation))),
    opp_rotation             = suppressWarnings(as.integer(last(opp_rotation))),
    score_diff_raw           = suppressWarnings(as.integer(last(score_diff))),
    timeout_after_point      = any(to_logical_vec(timeout), na.rm = TRUE),
    substitution_after_point = any(to_logical_vec(substitution), na.rm = TRUE),
    #home_team_won_rally      = last(to_logical_vec(home_team_won)),  # new
    won_match_rally          = last(to_logical_vec(won_match)),      # new
    home_team                = last(home_team),
    visiting_team            = last(visiting_team),
    won_set                  = last(won_set),
    date                     = last(date),
    season                   = last(season),
    conference               = last(conference),
    .groups = "drop"
  ) %>%
  arrange(match_id, set_number, rally_id)
```
(JUST NOTED: Touches in rally is incorrect due to nature of all-matches data set with "empty" rows)
-We collapse many touches into a single rally row. We take last scores to capture the scoreboard after the point, and any() over timeout/sub to mark whether the inter-point stoppage happened following that point.

```{r}
#add point winner info. 
points_w_winner <- points_core %>%
  group_by(match_id, set_number) %>%
  mutate(
    prev_home_end = lag(home_score_end, default = 0),
    prev_away_end = lag(away_score_end, default = 0),
    home_delta    = home_score_end - prev_home_end,
    away_delta    = away_score_end - prev_away_end,
    point_winner_team = case_when(
      home_delta == 1 & away_delta == 0 ~ home_team,
      away_delta == 1 & home_delta == 0 ~ visiting_team,
      TRUE ~ NA_character_            
    )
  ) %>%
  ungroup()
```
Had some problems with timeout booleans. So above is the fix. Exactly one side’s score should increase by 1 at a rally end. Using deltas bypasses missing point_won_by values and avoids problems assigning winners when TO/Sub rows appear.

```{r}
#CU focused variables 
points_cu <- points_w_winner %>%
  mutate(
    cu_is_home        = home_team == "CU",
    cu_score_end      = if_else(cu_is_home, home_score_end, away_score_end),
    opp_score_end     = if_else(cu_is_home, away_score_end, home_score_end),
    cu_point_won      = point_winner_team == "CU",
    cu_score_diff_end = cu_score_end - opp_score_end,
    cu_serving        = serving_team == "CU"
  )
```
By aligning columns to CU, we can analyze run lengths, in-rally momentum, and timeout efficacy without worrying about home/away flipping your signs.

**NEW SECTIONS
```{r}
#pre-rally state variables (for transitions)
points_cu <- points_cu %>%
  group_by(match_id, set_number) %>%
  arrange(rally_id) %>%
  mutate(
    cu_score_pre  = lag(cu_score_end, default = 0),
    opp_score_pre = lag(opp_score_end, default = 0),
    d_pre         = cu_score_pre - opp_score_pre
  ) %>%
  ungroup()
```

```{r}
#set/match + deciding vs nondeciding set 
points_cu <- points_cu %>%
  group_by(match_id) %>%
  mutate(
    total_sets = max(set_number, na.rm = TRUE),
    deciding_set = (set_number == total_sets),
    rally_in_match = row_number(),
    rally_prop_in_match = rally_in_match / n()
  ) %>%
  ungroup()
```

```{r}
#high leverage points 
points_cu <- points_cu %>%
  mutate(
    rally_importance = case_when(
      cu_score_end >= 20 | opp_score_end >= 20 ~ "late_set",
      TRUE ~ "early_mid_set"
    ),
    # Flag rallies where the score difference is small (≤ 2 points)
    #“close”//high-pressure moments
    close_score = abs(cu_score_diff_end) <= 2
  )
```

*may not use below but good to have.
```{r}
#momentum/clustering variables (detect run-length effects)
points_cu <- points_cu %>%
  group_by(match_id, set_number) %>%
  arrange(rally_id) %>%
  mutate(
    prev_win = lag(cu_point_won),
    # Assign a unique run ID whenever the rally result switches (win → loss)
    run_id = cumsum(cu_point_won != lag(cu_point_won, default = cu_point_won[1])),
    #Count how many rallies are in each consecutive run
    run_length = ave(seq_along(run_id), run_id, FUN = length)
  ) %>%
  ungroup()
```
** NEW SECTIONS DONE.

```{r}
#final set-level scores 
set_scores <- touches_flagged %>%
  group_by(match_id, set_number) %>%
  summarise(
    final_home_set_score = max(home_team_score, na.rm = TRUE),
    final_away_set_score = max(visiting_team_score, na.rm = TRUE),
    .groups = "drop"
  )
```

```{r}
points_final <- points_cu %>%
  left_join(set_scores, by = c("match_id", "set_number")) %>%
  select(
    match_id, date, season, conference,
    home_team, visiting_team, set_number, rally_id,
    cu_serving,
    cu_score_pre, opp_score_pre, d_pre,   # NEW
    cu_score_end, opp_score_end, cu_score_diff_end, cu_point_won,
    deciding_set, rally_importance, close_score, rally_in_match, rally_prop_in_match, run_length, prev_win, # NEW CONTEXT
    final_home_set_score, final_away_set_score,
    won_set,
    touches_in_rally, timeout_after_point, substitution_after_point,
    won_match_rally
  )
```

Final set scores provide outcome context for every rally (like late-set pressure).
```{r}
#output dataset
write_csv(points_final, out_path)

points <- points_final %>%
  na.omit()
```

```{r}
#export to github
readr::write_csv(points_final, "points_final.csv")
readr::write_csv(points_final, "points.csv")
```

Points_final: 27580, 30 variables 
variables: match_id, date, season, conference, home_team, visiting_team, set_number, rally_ud, cu_serving, cu_score_pre, opp_score_pre, d_pre, cu_score_end, opp_score_end, cu_score_diff_end, cu_point_won, deciding_set, rally_importance, close_score, rally_in_match, rall_prop_in_match, run_length, prev_win, final_home_set_score, final_away_set_score, won_set, touches_in_rally, timeout_after_point, substitution_after_point, won_match_rally

Points: 23365 entries , 30 variables (NO NAs)
variables: match_id, date, season, conference, home_team, visiting_team, set_number, rally_ud, cu_serving, cu_score_pre, opp_score_pre, d_pre, cu_score_end, opp_score_end, cu_score_diff_end, cu_point_won, deciding_set, rally_importance, close_score, rally_in_match, rall_prop_in_match, run_length, prev_win, final_home_set_score, final_away_set_score, won_set, touches_in_rally, timeout_after_point, substitution_after_point, won_match_rally

*Different Dataset Uses*
Use the clean (no NAs) dataset (points) for model fitting, validation, and markov property testing (assumptions).
Use the full dataset (points_final) for descriptive summaries, exploratory visuals, and robustness checks.


## Exploratory Analysis + General Summary Statstics 
```{r}
#quick overview of data 
summary(points)

#unique counts for both datasets 
points_final %>%
  summarize(
    matches = n_distinct(match_id),
    seasons = n_distinct(season),
    total_rallies = n(),
    unique_sets = n_distinct(paste(match_id, set_number))
  )

points %>%
  summarize(
    matches = n_distinct(match_id),
    seasons = n_distinct(season),
    total_rallies = n(),
    unique_sets = n_distinct(paste(match_id, set_number))
  )
```
For points_final: 169 matches in 7 seasons with 27580 total rallies and 628 unique sets. 27580, 30 variables 
For points: 148 matches, 6 seasons, 23365 total rallies, 548 unique sets.23365 entries , 30 variables (NO NAs)

```{r}
#Basic summary stats
points_final %>%
  summarize(
    total_rallies = n(),
    cu_point_pct = mean(cu_point_won, na.rm = TRUE),
    cu_serv_pct = mean(cu_serving, na.rm = TRUE),
    sideout_rate = mean(if_else(cu_serving, !cu_point_won, cu_point_won), na.rm = TRUE), # side-out success
    substitution_rate = mean(substitution_after_point, na.rm = TRUE),
    won_match_rate = mean(won_match_rally, na.rm = TRUE)
  ) %>% kable()

#point-win by serving status
points_final %>%
  group_by(cu_serving) %>%
  summarize(
    p_win = mean(cu_point_won, na.rm = TRUE),
    n = n()
  ) %>% knitr::kable()
```

CU points wins ~50.36% of all points, regardless of serving.
CU served ~50.19% of the rallies, roughly an equal distribution.

Side-out success ~ 58.35%
CU wins ~ 58.35% of points when receiving the serve(side-out success).

CU wins ~42.04% of points when serving.
CU wins ~58.75% of points when receiving the serve.

*Exploration Plots*
```{r}
# distribution of CU points at set end, by deciding vs non-deciding sets
points_final %>%
  group_by(match_id, set_number) %>%
  slice_tail(n = 1) %>%  # last rally of each set
  ungroup() %>%
  ggplot(aes(x = cu_score_end)) +
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~ deciding_set, 
             labeller = labeller(deciding_set = c(`FALSE` = "Non-Deciding Set", `TRUE` = "Deciding Set"))) +
  labs(
    title = "Distribution of CU Points at Set End",
    x = "CU Points at Set End",
    y = "Count of Sets"
  ) +
  theme_minimal()
```
Non-deciding sets have a greater number of sets with a) greater distribution of points at the sets end b) greater count of sets at a higher (more likely a win) # of points.

```{r}
#table of common final scores
set_scores_cu %>%
  count(cu_final, opp_final) %>%
  arrange(desc(n)) %>%
  head(10) %>%
  knitr::kable()
```

```{r}
#Distribution of substitutions per rally
ggplot(points_final, aes(x = substitution_after_point)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Distribution of Substitutions After Rallies",
       x = "Substitution Occurred?",
       y = "Number of Rallies")

#Substitution effect on CU points
points_final %>%
  group_by(substitution_after_point) %>%
  summarize(
    avg_cu_point = mean(cu_point_won, na.rm = TRUE),
    n = n()
  ) %>% kable()
```

```{r}
#serve impact bar plot
points_final %>%
  group_by(cu_serving) %>%
  summarise(win_prob = mean(cu_point_won, na.rm = TRUE)) %>%
  ggplot(aes(x = cu_serving, y = win_prob, fill = cu_serving)) +
  geom_col() +
  labs(title = "Effect of Serving on Rally Win Probability",
       x = "CU Serving?", y = "Win Probability")
```

```{r}
#rally vs score dynamics 
#win rate by score difference
points_final %>%
  mutate(score_bin = cut(cu_score_diff_end, breaks = seq(-10, 10, 2))) %>%
  group_by(score_bin) %>%
  summarise(win_prob = mean(cu_point_won, na.rm = TRUE)) %>%
  ggplot(aes(x = score_bin, y = win_prob)) +
  geom_col(fill = "steelblue") +
  labs(title = "CU Rally Win Probability by Score Differential",
       x = "Score Differential (CU - Opp)", y = "Probability of Winning Next Rally")
```
Shows how win chances shift as CU leads or trails, key for identifying leverage state.

```{r}
#Momentum/ Run Length Analysis 
# Win probability conditional on previous rally outcome
points_final %>%
  group_by(prev_win) %>%
  summarise(win_prob = mean(cu_point_won, na.rm = TRUE)) %>%
  ggplot(aes(x = as.factor(prev_win), y = win_prob, fill = as.factor(prev_win))) +
  geom_col() +
  labs(title = "Momentum Effect: Win Probability by Previous Rally Outcome",
       x = "Won Previous Rally?", y = "Probability of Winning Next Rally")

# Distribution of rally run lengths
points_final %>%
  ggplot(aes(x = run_length)) +
  geom_histogram(binwidth = 1, fill = "goldenrod", color = "black") +
  labs(title = "Distribution of Rally Run Lengths", x = "Run Length", y = "Frequency")
```
Tests whether winning or losing streaks affect rally outcomes.

```{r}
#Rally Importance + Closeness
# Win rate by rally importance and closeness
points_final %>%
  group_by(rally_importance, close_score) %>%
  summarise(win_prob = mean(cu_point_won, na.rm = TRUE)) %>%
  ggplot(aes(x = rally_importance, y = win_prob, fill = close_score)) +
  geom_col(position = "dodge") +
  labs(title = "Win Probability by Rally Importance and Score Closeness",
       x = "Rally Stage", y = "Win Probability")
```
Highlights whether CU performs differently under pressure (close, late rallies). No apperance of a difference. 

```{r}
# Win probability by set type 
points_final %>%
  group_by(match_id, set_number, deciding_set) %>%   # aggregate at set level
  summarise(cu_won_set = max(won_set, na.rm = TRUE), .groups = "drop") %>%  # won_set is binary per set
  group_by(deciding_set) %>%
  summarise(win_prob = mean(cu_won_set), .groups = "drop") %>%  # average across sets
  ggplot(aes(x = deciding_set, y = win_prob, fill = deciding_set)) +
  geom_col() +
  scale_x_discrete(labels = c("Non-Deciding", "Deciding")) +
  labs(
    title = "CU Set Win Probability by Set Type",
    x = "Set Type",
    y = "Win Probability"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
#seasonal patterns 
points_final %>%
  group_by(season) %>%
  summarise(season_win_rate = mean(cu_point_won, na.rm = TRUE)) %>%
  ggplot(aes(x = as.numeric(season), y = season_win_rate)) +
  geom_line(linewidth = 1.2, color = "darkblue") +
  geom_point(size = 2) +
  labs(title = "CU Rally Win Rate Across Seasons",
       x = "Season", y = "Win Rate")
```

```{r}
#HEATMAP: win probabilities 
points_final %>%
  count(cu_score_end, opp_score_end, wt = cu_point_won, name = "wins") %>%
  left_join(count(points_final, cu_score_end, opp_score_end, name = "total"),
            by = c("cu_score_end", "opp_score_end")) %>%
  mutate(win_prob = wins / total) %>%
  ggplot(aes(x = opp_score_end, y = cu_score_end, fill = win_prob)) +
  geom_tile() +
  scale_fill_viridis_c(option = "plasma") +
  labs(title = "Heatmap of CU Rally Win Probability by Score State",
       x = "Opponent Score", y = "CU Score", fill = "Win Prob")
```


##Markov Modeling Outcomes (Ethans w/ Sydneys new dataset)
```{r}
pbp <- points

pbp2 <- pbp %>%
  mutate(
    y  = as.integer(cu_point_won),          #1 if CU won rally, 0 otherwise
    cu_score_pre  = cu_score_end  - y,
    opp_score_pre = opp_score_end - (1L - y),
    d_pre = cu_score_pre - opp_score_pre,   #Score differential before rall
    cu_serv = as.integer(cu_serving)
  ) %>%
  filter(y %in% c(0,1), cu_serv %in% c(0,1)) %>%
  drop_na(y, d_pre, cu_serv)
```

```{r}
#logistic regression model(markov transition model)
m_point <- glm(
  y ~ d_pre + I(d_pre^2) + cu_serv,
  data = pbp2, family = binomial()
)
summary(m_point)
coef(m_point)  
#forms transition kernel of the markov chain 
```

##NEW MODEL TO IMPLEMENT INTO CODE BELOW 
```{r}
m_point2 <- glm(
  y ~ 
    d_pre + I(d_pre^2) +
    run_length+ cu_serv,
  data = pbp2,
  family = binomial()
)
summary(m_point2)
#plot(m_point2)
```

```{r}
#Probability function for Model Predictions 
CLAMP_DIFF <- 12L
clamp <- function(x, lo, hi) pmax(lo, pmin(hi, x))

#returns predicted win probability given any score differential + serving status 
p_hat <- (function(beta) {
  b0 <- unname(beta["(Intercept)"])
  b1 <- unname(beta["d_pre"])
  b2 <- unname(beta["I(d_pre^2)"])
  b3 <- unname(beta["cu_serv"])
  function(d_pre, cu_serv){
    d <- clamp(d_pre, -CLAMP_DIFF, CLAMP_DIFF)
    eta <- b0 + b1*d + b2*(d^2) + b3*as.numeric(cu_serv)
    plogis(eta)
  }
})(coef(m_point))
```

```{r}
#Markov Chain Value Iteration Setup 
#(win by 2, to 25+)
TARGET     <- 25L
MAX_SCORE  <- 50L   # generous cap to cover long deuce stretches
SERVERS    <- 0:1   # 0 = opp serve, 1 = CU serve

# Array V[cu+1, opp+1, srv+1] stores CU set win prob from that state
V <- array(0, dim = c(MAX_SCORE+1, MAX_SCORE+1, 2))

#terminal states 
is_terminal <- function(cu, opp) {
  (cu >= TARGET || opp >= TARGET) && abs(cu - opp) >= 2
}

# Initialize terminal states
for (cu in 0:MAX_SCORE) {
  for (opp in 0:MAX_SCORE) {
    if (is_terminal(cu, opp)) {
      val <- if (cu > opp) 1.0 else 0.0
      V[cu+1, opp+1, 1] <- val
      V[cu+1, opp+1, 2] <- val
    }
  }
}

#value iteration 
step_value <- function(V){
  Vnew <- V
  for (cu in 0:MAX_SCORE) {
    for (opp in 0:MAX_SCORE) {
      for (srv in SERVERS) {
        if (is_terminal(cu, opp)) next
        # CU rally win probability from (cu, opp, srv):
        p <- p_hat(cu - opp, srv)
        # Transitions:
        cu_win_cu   <- min(cu + 1L, MAX_SCORE)
        cu_win_opp  <- opp
        cu_win_srv  <- 1L  # CU serves after CU wins rally
        cu_lose_cu  <- cu
        cu_lose_opp <- min(opp + 1L, MAX_SCORE)
        cu_lose_srv <- 0L  # OPP serves after CU loses rally
        Vnew[cu+1, opp+1, srv+1] <-
          p * V[cu_win_cu+1,  cu_win_opp+1,  cu_win_srv+1] +
          (1-p) * V[cu_lose_cu+1, cu_lose_opp+1, cu_lose_srv+1]
      }
    }
  }
  Vnew
}

# Iterate to convergence
max_iters <- 400L
tol <- 1e-10
for (it in 1:max_iters) {
  Vnew <- step_value(V)
  delta <- max(abs(Vnew - V))
  V <- Vnew
  if (delta < tol) {
    message(sprintf("Converged in %d iterations (delta=%.3g)", it, delta))
    break
  }
}
```

```{r}
#extracting + viewing results 
v_state <- function(cu, opp, cu_serve) {
  V[cu+1, opp+1, cu_serve+1]
}
```

```{r}
#key state table
key_states <- tribble(
  ~state,                         ~cu, ~opp, ~srv,
  "Start (0-0, CU serve)",         0L,  0L,   1L,
  "Start (0-0, OPP serve)",        0L,  0L,   0L,
  "Late: 24-23, CU serve",        24L, 23L,   1L,
  "Late: 24-23, OPP serve",       24L, 23L,   0L,
  "Late: 23-24, CU serve",        23L, 24L,   1L,
  "Late: 23-24, OPP serve",       23L, 24L,   0L
) %>%
  mutate(
    cu_serve = if_else(srv == 1L, "Yes", "No"),
    `CU set win probability` = pmap_dbl(list(cu, opp, srv), ~ v_state(..1, ..2, ..3))
  ) %>%
  select(state, cu_points = cu, opp_points = opp, cu_serve, `CU set win probability`)

knitr::kable(key_states, digits = 4, align = c("l","r","r","c","r"))

key_states
```

```{r}
#deuce region grid 
deuce_grid <- expand.grid(
  cu  = 22:25,
  opp = 22:25,
  srv = c(1L, 0L)
) %>%
  as_tibble() %>%
  mutate(
    cu_serve = if_else(srv == 1L, "Yes", "No"),
    `CU set win probability` = pmap_dbl(list(cu, opp, srv), ~ v_state(..1, ..2, ..3))
  ) %>%
  arrange(cu, opp, desc(cu_serve)) %>%
  select(cu_points = cu, opp_points = opp, cu_serve, `CU set win probability`)

knitr::kable(deuce_grid, digits = 4)

deuce_grid
```

```{r}
#Function: return CU set win probability for any state
get_set_win_prob <- function(cu_points, opp_points, cu_serving) {
  # cu_points: integer (0–25+)
  # opp_points: integer (0–25+)
  # cu_serving: 1 if CU serving, 0 if opponent serving
  
  # Clamp inputs to grid boundaries
  cu <- pmin(pmax(cu_points, 0L), MAX_SCORE)
  opp <- pmin(pmax(opp_points, 0L), MAX_SCORE)
  srv <- ifelse(cu_serving %in% c(1, TRUE), 1L, 0L)
  
  # Retrieve from the Markov value matrix V
  prob <- V[cu + 1, opp + 1, srv + 1]
  return(prob)
}
```

```{r}
# Example 1: Start of set, CU serving
get_set_win_prob(0, 0, 1)
# Example 2: Start of set, Opp serving
get_set_win_prob(0, 0, 0)
# Example 3: Deuce scenario (24-23, CU serve)
get_set_win_prob(24, 23, 1)
# Example 4: Opponent leads 22-24, opponent serving
get_set_win_prob(22, 24, 0)

get_set_win_prob(15,19,0)
                 
get_set_win_prob(15,15,1)

get_set_win_prob(15,15,0)
```

```{r}
build_grid_safe <- function(range_limit = 30L) {
  stopifnot(exists("V"), exists("get_set_win_prob"))
  expand.grid(
    cu  = 0:range_limit,
    opp = 0:range_limit,
    srv = c(0L, 1L)        # 0 = opp serve, 1 = CU serve
  ) %>%
    as_tibble() %>%
    mutate(
      cu_serve = if_else(srv == 1L, "CU serve", "Opp serve"),
      prob = pmap_dbl(
        list(cu, opp, srv),
        ~ get_set_win_prob(..1, ..2, ..3)  # one lookup per row
      )
    )
}

grid30 <- build_grid_safe(30L)
```

```{r}
build_deuce_band <- function(lo = 22L, hi = 30L) {
  expand.grid(
    cu  = lo:hi,
    opp = lo:hi,
    srv = c(0L, 1L)
  ) %>%
    as_tibble() %>%
    mutate(
      cu_serve = if_else(srv == 1L, "CU serve", "Opp serve"),
      prob = pmap_dbl(list(cu, opp, srv), ~ get_set_win_prob(..1, ..2, ..3))
    )
}
band <- build_deuce_band(22L, 30L)
```

Visualization.
```{r}
# 1) Heatmap by serving status
ggplot(grid30, aes(x = opp, y = cu, fill = prob)) +
  geom_tile() +
  facet_wrap(~ cu_serve) +
  scale_fill_viridis_c(name = "CU set win\nprobability", limits = c(0,1)) +
  coord_equal() +
  labs(x = "Opponent points", y = "CU points",
       title = "Set win probability across score states by server") +
  theme_minimal(base_size = 12)

# 2) Deuce band with contours
ggplot(band, aes(x = opp, y = cu)) +
  geom_tile(aes(fill = prob)) +
  geom_contour(aes(z = prob), breaks = seq(0.5, 0.9, by = 0.05),
               color = "white", linewidth = 0.35) +
  facet_wrap(~ cu_serve) +
  scale_fill_viridis_c(name = "CU set win\nprobability", limits = c(0,1)) +
  coord_equal() +
  labs(x = "Opponent points", y = "CU points",
       title = "Deuce band (22–30): set win probability by server") +
  theme_minimal(base_size = 12)
```

```{r}
# Create a dataframe of all possible score states and serve conditions
make_state_df <- function(max_score = 30L) {
  expand.grid(
    cu_points  = 0:max_score,
    opp_points = 0:max_score,
    cu_serving = c(0L, 1L)   # 0 = Opp serve, 1 = CU serve
  ) %>%
    as_tibble() %>%
    mutate(
      cu_serve_label = if_else(cu_serving == 1L, "CU serve", "Opp serve"),
      win_probability = pmap_dbl(
        list(cu_points, opp_points, cu_serving),
        ~ get_set_win_prob(..1, ..2, ..3)
      )
    )
}

# Generate for 0–30 range
state_df <- make_state_df(30L)

# Preview
dplyr::glimpse(state_df)
```




## RESEARCH QUESTIONS
#Q1: Are there high-leverage scores?
```{r}
points <- points %>%
  mutate(
    win_prob_before = get_set_win_prob(cu_score_pre, opp_score_pre, as.integer(cu_serving)),
    win_prob_after  = get_set_win_prob(cu_score_end, opp_score_end, as.integer(cu_serving)),
    leverage = abs(win_prob_after - win_prob_before)
  )

ggplot(points, aes(x = cu_score_end, y = opp_score_end, fill = leverage)) +
  geom_tile() +
  scale_fill_viridis_c(option = "plasma") +
  labs(title = "Rally Leverage: Change in CU Set Win Probability per Rally",
       x = "Opponent Score", y = "CU Score", fill = "Δ Win Prob") +
  coord_equal()
```

#Q2: Are there ways of grouping scores together into discrete categories by their win probabilities?
```{r}
grid30 %>%
  mutate(win_group = cut(prob, breaks = c(0, 0.25, 0.5, 0.75, 1),
                         labels = c("Low", "Medium", "High", "Very High"))) %>%
  ggplot(aes(x = opp, y = cu, fill = win_group)) +
  geom_tile() +
  facet_wrap(~ cu_serve) +
  scale_fill_manual(values = c("#F8766D", "#7CAE00", "#00BFC4", "#C77CFF")) +
  labs(title = "Score Regions Grouped by CU Set Win Probability",
       x = "Opponent Score", y = "CU Score", fill = "Win Group")
```


#Q3: How do win probabilities differ between non-deciding sets and deciding sets?
```{r}
m_deciding <- glm(y ~ d_pre + I(d_pre^2) + cu_serv,
                  data = pbp2, family = binomial(), subset = deciding_set)
m_nondeciding <- glm(y ~ d_pre + I(d_pre^2) + cu_serv,
                     data = pbp2, family = binomial(), subset = !deciding_set)

broom::tidy(m_deciding)
broom::tidy(m_nondeciding)
```

```{r}
points_final %>%
  mutate(prob = get_set_win_prob(cu_score_end, opp_score_end, as.integer(cu_serving))) %>%
  ggplot(aes(x = rally_prop_in_match, y = prob, color = as.factor(set_number))) +
  geom_line(alpha = 0.7) +
  labs(title = "Evolution of CU Win Probability Across Sets",
       x = "Rally Progression (0–1 within match)", y = "Win Probability", color = "Set #") +
  theme_minimal()
```



##Q4 BIG QUESTION: How do win probabilities change as we go through different scores and through different sets? (+ overall match)

#Diagnostic Testing 
A. Logistic Regression (Rally-Level Markov Model) Diagnostics
```{r}
#Residual Analysis
# Pearson residuals
resid_pearson <- residuals(m_point2, type = "pearson")
hist(resid_pearson, breaks = 50, main = "Histogram of Pearson Residuals", xlab = "Residual")

plot(fitted(m_point), residuals(m_point2, type = "pearson"))
abline(h = 0, col = "red")

# Pearson residuals
res_pearson <- residuals(m_point2, type = "pearson")
summary(res_pearson)
mean(res_pearson^2)  # should be ~1 if model fits well
```

```{r}
#Multicollinearity Check
vif(m_point2)
```
This is good, close to 1 means no correlation between predictors. 

```{r}
#Model specification / goodness-of-fit
# Likelihood ratio test vs null model
null_model <- glm(y ~ 1, data = pbp2, family = binomial()) 
anova(null_model, m_point2, test = "Chisq") 

# AIC / BIC for model comparison
AIC(m_point2) 
BIC(m_point2)
```
Goodness of fit NOT GOOD.

```{r}
# Cook's distance
cooks_d <- cooks.distance(m_point2)
summary(cooks_d)
# Threshold often 4 / n
influential <- which(cooks_d > 4 / nrow(pbp2))
length(influential)  # number of influential points
```
LOTS OF INFLUENTIAL POINTS==NOTED

```{r}
#model fit aswell 
# Hosmer–Lemeshow test
library(ResourceSelection)
hoslem.test(pbp2$y, fitted(m_point2), g=10)  # g = number of groups

# Brier score
mean((fitted(m_point2) - pbp2$y)^2)
```

```{r}
# AUC / ROC
library(pROC)
roc_obj <- roc(pbp2$cu_point_won, fitted(m_point2))
auc(roc_obj)
```

```{r}
#overdispersion 
# Residual deviance / residual df
overdispersion_ratio <- deviance(m_point2) / df.residual(m_point2)
overdispersion_ratio  # ~1 is good; >>1 may indicate overdispersion
```


B. Markov Chain / Value Iteration Validation
```{r}
#Transition Probability Validation
# Compare predicted probability to observed next-rally outcomes
pbp_val <- pbp %>%
  mutate(pred_prob = p_hat(d_pre, as.integer(cu_serving)))

ggplot(pbp_val, aes(x = pred_prob, y = cu_point_won)) +
  geom_jitter(height = 0.02, alpha = 0.3) +
  geom_smooth(method = "loess", col = "red") +
  labs(title = "Predicted vs Observed Rally Outcomes", x = "Predicted Probability", y = "Actual Outcome")
```

```{r}
#Binned Calibration Plot
pbp_val %>%
  mutate(bin = cut(pred_prob, breaks = seq(0, 1, by = 0.1))) %>%
  group_by(bin) %>%
  summarise(obs_prob = mean(cu_point_won), pred_prob = mean(pred_prob), n = n()) %>%
  ggplot(aes(x = pred_prob, y = obs_prob)) +
  geom_point(size = 2) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  labs(title = "Calibration of Logistic/Markov Model",
       x = "Predicted Probability", y = "Observed Probability")
```

```{r}
#Cross-Validation / Predictive Accuracy
library(caret)
set.seed(22)
trainIndex <- createDataPartition(pbp$cu_point_won, p = 0.7, list = FALSE)
train <- pbp[trainIndex, ]
test  <- pbp[-trainIndex, ]

mod <- glm(cu_point_won ~ d_pre + I(d_pre^2) + cu_serving, data = train, family = binomial())
pred <- predict(mod, test, type = "response")
conf_matrix <- table(Pred = pred > 0.5, Actual = test$cu_point_won)
conf_matrix
```

```{r}
library(pROC)
roc_obj <- roc(test$cu_point_won, pred)
auc(roc_obj)
plot(roc_obj)
```

C. Model Validation for Value Iteration / Markov.
```{r}
simulate_set <- function(start_cu = 0, start_opp = 0, start_srv = 1) {
  cu <- start_cu
  opp <- start_opp
  srv <- start_srv
  while(!is_terminal(cu, opp)) {
    p <- p_hat(cu - opp, srv)
    win <- rbinom(1, 1, p)
    if(win) {
      cu <- cu + 1
      srv <- 1
    } else {
      opp <- opp + 1
      srv <- 0
    }
  }
  cu > opp  # returns TRUE if CU wins the set
}

# Run many simulations
set.seed(42)
results <- replicate(1000, simulate_set())
mean(results)  # Empirical set win probability
```

D. Diagnostics Specific to Markov / Transition Assumptions.
```{r}
#check markov property
# Does P(Point win | current score) depend only on current score & server?
library(randtests)

# Example: Runs test on sequence of wins/losses conditional on score
pbp$sequence <- pbp$cu_point_won
runs.test(as.factor(pbp$sequence))
```

```{r}
#Residuals Across Score States
pbp$pred_prob <- p_hat(pbp$d_pre, as.integer(pbp$cu_serving))
pbp$resid <- pbp$cu_point_won - pbp$pred_prob

# Heatmap of residuals
pbp %>%
  group_by(cu_score_pre, opp_score_pre) %>%
  summarise(resid_mean = mean(resid), .groups = "drop") %>%
  ggplot(aes(x = opp_score_pre, y = cu_score_pre, fill = resid_mean)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  labs(title = "Mean Residuals Across Score States", x = "Opp Score Pre-Rally", y = "CU Score Pre-Rally")
```

