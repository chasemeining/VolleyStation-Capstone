---
title: "STAT_capstone"
output: word_document
date: "2025-09-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(out.width = "60%",fig.align='center')
```

## Load Libraries 
```{r}
install.packages("here")   # only once allows us to all call from same space 
```
```{r}
library(tidyverse)
library(knitr)
library(tinytex) 
library(dplyr)
library(ggplot2)
library(readr)
library(tibble) #make table
library(here)
```

## Load Datasets
```{r}
all_matches_CU <- readr::read_csv(here("datasets", "all_matches_CU.csv"))                #551 by 16
all_matches_opp <- readr::read_csv(here("datasets","all_matches_opp.csv"))               #551 by 16
all_matches_processed <- readr::read_csv(here("datasets","all_matches_processed.csv"))  #1102 by 16
all_matches <- readr::read_csv(here("datasets","all_matches (1).csv"))                 #269628 by 125 
```

```{r}
all_matches_raw <- readr::read_csv(here("datasets","all_matches_raw.csv"))              #269628 by 87
conference_matches_raw <- readr::read_csv(here("datasets","conference_matches_raw.csv"))   #168769 by 87
dirty_conference_matches_raw <- readr::read_csv(here("datasets","dirty_conference_matches_raw.csv"))   #259250 by 87
dirty_conference_matches <- readr::read_csv(here("datasets","dirty_conference_matches.csv"))          #259250 by 125
```


## Cleaning + Wrangling Data 
```{r}
#ALL MATCHES RAW
#selecting relevant/important variables
all_matches_raw1 <- all_matches_raw %>%
  select(match_id, point_id, time,team, player_number, player_name, player_id, skill, timeout, end_of_set, substitution, point, home_team_score, visiting_team_score, file_line_number, home_p1, home_p2, home_p3, home_p4, home_p5, home_p6, visiting_p1, visiting_p2, visiting_p3, visiting_p4, visiting_p5)  #269628 by 26 vars.

#checking NAs in data
na_count <- colSums(is.na(all_matches_raw1))
na_count_tbl <- enframe(na_count, name = "column", value = "num_NAs")
na_count_tbl
#shows us to take out set_code, set_type, start_zone, end_zone

all_matches_raw2 <- all_matches_raw1 %>%
  na.omit()    #269628 by 26 vars. -> 199758 observations 
```

```{r}
#CONFERENCE MATCHES RAW
conference_matches_raw1 <- conference_matches_raw %>%
  select(match_id, point_id, time,team, player_number, player_name, player_id, skill, timeout, end_of_set, substitution, point, home_team_score, visiting_team_score, file_line_number, home_p1, home_p2, home_p3, home_p4, home_p5, home_p6, visiting_p1, visiting_p2, visiting_p3, visiting_p4, visiting_p5)

#checking NAs in data
na_count <- colSums(is.na(conference_matches_raw1))
na_count_tbl <- enframe(na_count, name = "column", value = "num_NAs")
na_count_tbl

conference_matches_raw2 <- conference_matches_raw1 %>%
  na.omit()  # 168769 -> 125559 observations , 26 vars. 
```

```{r}
#DIRTY CONFERENCE MATCHES RAW 
dirty_conference_matches_raw1 <- dirty_conference_matches_raw %>%
  select(match_id, point_id, time,team, player_number, player_name, player_id, skill, timeout, end_of_set, substitution, point, home_team_score, visiting_team_score, file_line_number, home_p1, home_p2, home_p3, home_p4, home_p5, home_p6, visiting_p1, visiting_p2, visiting_p3, visiting_p4, visiting_p5)

#checking NAs in data
na_count <- colSums(is.na(dirty_conference_matches_raw1))
na_count_tbl <- enframe(na_count, name = "column", value = "num_NAs")
na_count_tbl
dirty_conference_matches_raw2 <- dirty_conference_matches_raw1 %>%
  na.omit()  # 259250 -> 192550 observations , 26 vars. 
```


#ETHANS WORKFLOW 
```{r}
#possible add data filtering before this 
```

```{r}
#data inflow + outflow
#in_path  <- "all_matches"
in_path <- here::here("datasets", "all_matches (1).csv")
out_path <- "volleyball_points_dataset.csv"
```

```{r}
#touches <- read_csv(in_path, show_col_types = FALSE)
touches <- readr::read_csv(in_path, show_col_types = FALSE)

order_col <- if ("Unnamed: 0" %in% names(touches)) "Unnamed: 0" else NULL

#touches in correspondence to rally order
touches_ord <- touches %>%
  {
    if (!is.null(order_col)) arrange(., match_id, set_number, .data[[order_col]])
    else group_by(., match_id, set_number) %>% arrange(row_number(), .by_group = TRUE) %>% ungroup()
  }
```

To compress rallies accurately, touches must be sorted in the exact sequence they occurred. We sort by match_id, set_number, and a stable row index so subsequent steps (like detecting score changes) behave correctly.

```{r}
#add flags for rally IDS + rally-ending scores 
touches_flagged <- touches_ord %>%
  group_by(match_id, set_number) %>%
  mutate(
    prev_home  = lag(home_team_score),
    prev_away  = lag(visiting_team_score),
    rally_end_flag = (home_team_score != prev_home) | (visiting_team_score != prev_away),
    rally_end_flag = replace_na(rally_end_flag, TRUE),
    rally_id = cumsum(rally_end_flag)
  ) %>%
  ungroup()
```

Volleyball is rally scoring; each rally ends when the scoreboard moves. By turning score changes into a “flag” and cumulatively summing, every touch is assigned to the rally that produced (or followed) a point.

```{r}
#function to create binaries (T/F)
to_logical_vec <- function(x) {
  if (is.logical(x)) x
  else if (is.numeric(x)) x != 0
  else tolower(as.character(x)) %in% c("true","t","yes","y","1")
}
```

“Between points” events like timeouts are often recorded right after a point and before the next serve. We’ll roll them up with the rally that just ended (i.e., the point that triggered them).

```{r}
#collapse touches into rally-level dataset
points_core <- touches_flagged %>%
  group_by(match_id, set_number, rally_id) %>%
  summarise(
    home_score_end        = last(home_team_score),
    away_score_end        = last(visiting_team_score),
    serving_team          = first(serving_team),          
    touches_in_rally      = n(),
    team_rotation         = suppressWarnings(as.integer(last(team_rotation))),
    opp_rotation          = suppressWarnings(as.integer(last(opp_rotation))),
    score_diff_raw        = suppressWarnings(as.integer(last(score_diff))),
    timeout_after_point   = any(to_logical_vec(timeout), na.rm = TRUE),
    substitution_after_point = any(to_logical_vec(substitution), na.rm = TRUE),
    home_team             = last(home_team),
    visiting_team         = last(visiting_team),
    won_set               = last(won_set),
    date                  = last(date),
    season                = last(season),
    conference            = last(conference),
    .groups = "drop"
  ) %>%
  arrange(match_id, set_number, rally_id)

```

(JUST NOTED: Touches in rally is incorrect due to nature of all-matches data set with "empty" rows)

We collapse many touches into a single rally row. We take last scores to capture the scoreboard after the point, and any() over timeout/sub to mark whether the inter-point stoppage happened following that point.

```{r}
#add point winner info. 
points_w_winner <- points_core %>%
  group_by(match_id, set_number) %>%
  mutate(
    prev_home_end = lag(home_score_end, default = 0),
    prev_away_end = lag(away_score_end, default = 0),
    home_delta    = home_score_end - prev_home_end,
    away_delta    = away_score_end - prev_away_end,
    point_winner_team = case_when(
      home_delta == 1 & away_delta == 0 ~ home_team,
      away_delta == 1 & home_delta == 0 ~ visiting_team,
      TRUE ~ NA_character_            
    )
  ) %>%
  ungroup()
```

Had some problems with timeout booleans. So above is the fix. Exactly one side’s score should increase by 1 at a rally end. Using deltas bypasses missing point_won_by values and avoids problems assigning winners when TO/Sub rows appear.

```{r}
#CU focused variables 
points_cu <- points_w_winner %>%
  mutate(
    cu_is_home        = home_team == "CU",
    cu_score_end      = if_else(cu_is_home, home_score_end, away_score_end),
    opp_score_end     = if_else(cu_is_home, away_score_end, home_score_end),
    cu_point_won      = point_winner_team == "CU",
    cu_score_diff_end = cu_score_end - opp_score_end,
    cu_serving        = serving_team == "CU"
  )

```

By aligning columns to CU, we can analyze run lengths, in-rally momentum, and timeout efficacy without worrying about home/away flipping your signs.

```{r}
#final set-level scores 
set_scores <- touches_flagged %>%
  group_by(match_id, set_number) %>%
  summarise(
    final_home_set_score = max(home_team_score, na.rm = TRUE),
    final_away_set_score = max(visiting_team_score, na.rm = TRUE),
    .groups = "drop"
  )

#combination of rally-level + set-level 
points_final <- points_cu %>%
  left_join(set_scores, by = c("match_id", "set_number")) %>%
  select(
    match_id, date, season, conference,
    home_team, visiting_team, set_number, rally_id,
    cu_serving,
    cu_score_end, opp_score_end, cu_score_diff_end, cu_point_won,
    final_home_set_score, final_away_set_score,
    won_set,
  )
```

Final set scores provide outcome context for every rally (like late-set pressure).

```{r}
#output dataset
write_csv(points_final, out_path)
head(points_final, 10)
```

## Exploratory Analysis



## Assumptions


#Markov Chain Modeling 
```{r}
pbp <- read_csv("C:/Users/ethan/Downloads/volleyball_points_dataset.csv", show_col_types = FALSE)

# --- derive pre-rally differential from end-of-rally scores ---
pbp2 <- pbp %>%
  mutate(
    y = as.integer(cu_point_won),        # outcome
    cu_score_pre  = cu_score_end  - y,   # pre-rally CU score
    opp_score_pre = opp_score_end - (1L - y), # pre-rally opp score
    d_pre = cu_score_pre - opp_score_pre,
    cu_serv = as.integer(cu_serving)     # CU serving (already 0/1)
  ) %>%
  filter(y %in% c(0,1), cu_serv %in% c(0,1))

# --- fit simplified logistic model ---
m_point <- glm(
  y ~ poly(d_pre, 2, raw = TRUE) + cu_serv,
  data = pbp2, family = binomial()
)

summary(m_point)

# --- build table of predicted probabilities for diffs -7..7 ---
diff_grid <- expand.grid(
  d_pre = -7:7,
  cu_serv = c(0,1)
)

pred_table <- diff_grid %>%
  mutate(
    eta = predict(m_point, newdata = diff_grid, type = "link"),
    p_hat = plogis(eta),
    cu_serving = ifelse(cu_serv == 1, "Yes", "No")
  ) %>%
  select(d_pre, cu_serving, p_hat)

print(pred_table)


```

1.  **Define the state space.**\
    A state is the pre-rally score and server: $$
    (a,b,s),\quad a=\text{CU points},\; b=\text{opponent points},\; s\in\{\text{CU},\text{Opp}\}.
    $$ Absorbing if $a\ge T$ and $a-b\ge2$ (CU wins) or $b\ge T$ and $b-a\ge2$ (opp wins), with $T=25$ (or $15$ in the deciding set).

2.  **Estimate point-win probabilities.**\
    Fit a logistic model for $$
    p(d,s)=\Pr(\text{CU wins next rally}\mid d,s),
    $$ where $d=a-b$ (score differential) and $s$ is whether CU is serving.

3.  **Map to transitions.**\
    From any non-absorbing $(a,b,s)$:

    -   with probability $p(d,s)$ go to $(a+1,b,\text{CU})$\
    -   with probability $1-p(d,s)$ go to $(a,b+1,\text{Opp})$\
        (Rally winner serves next.)

4.  **Solve the absorbing Markov chain.**\
    Let $W(a,b,s)$ be the probability CU wins the set from $(a,b,s)$. Then $$
    W(a,b,s)=p(d,s)\,W(a+1,b,\mathrm{CU})+\big(1-p(d,s)\big)\,W(a,b+1,\mathrm{Opp}),
    $$ with $W=1$ in CU-win absorbing states and $W=0$ in CU-loss absorbing states. Compute via memoized recursion (DP).

5.  **Attach live win probabilities.**\
    For each rally, compute pre-rally $(a,b)$, serving $s$, and $T$; evaluate $W(a,b,s)$ to get pre-rally set win probability.

6.  **Validate & calibrate.**\
    Use Brier score and reliability plots; check that WP rises after CU-won rallies and falls after losses.

7.  **(Maybe) Extend to match-win probability.**\
    Embed set-level $W$ in a best-of-five framework, tracking sets won until a team reaches three.
